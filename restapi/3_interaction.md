클라이언트는 상호작용하려는 메서드를 HTTP 요청 메시지의 Request-Line 부 분에 명시한다. RFC 2616에서는 Request-Line 문법을 다음과 같이 정의한다.
Request-Line = Method SP Request-URI SP HTTP-Version CRLF (SP: Space, CRLF: Carriage Return Line Feed)
REST API 리소스 모델에서 각 HTTP 메서드는 잘 정의된 고유한 의미가 있다. GET 메서드는 리소스 상태의 표현(리소스의 상태가 어떤지를 나타내는 값)을


얻을 때 사용하며, HEAD 메서드는 리소스 상태에 대한 메타데이터를 얻을 때 사 용한다. PUT 메서드는 새로운 리소스를 스토어에 추가하거나 기존 리소스를 갱신 할 때 사용한다. DELETE 메서드는 부모에서 리소스를 제거한다. POST 메서드는 컬렉션에 새로운 리소스를 만들거나 컨트롤러를 실행할 때 사용한다.


규칙: GET 메서드나 POST 메서드를 사용하여 다른 요청 메서드를 처리해서 는 안 된다
터널링tunneling은 메시지의 원래 의도를 감추거나 잘못 표현하는 것, 프로토콜의 투 명성을 훼손하는 것 등의 HTTP 오용을 의미한다. 한정된 HTTP 문법으로 클라 이언트에 대응하기 위해서 HTTP 요청 메서드를 원래의 의미와 다르게 사용하는 REST API를 설계해서는 안 된다. 이 부분에서 소개하는 규칙에 따라, 항상 명확하 게 기술한 올바른 HTTP 메서드를 사용해야 한다.
규칙: GET 메서드는 리소스의 상태 표현을 얻는 데 사용해야 한다
REST API 클라이언트는 특정한 형식의 GET 메서드를 요청 메시지에 추가하여 리 소스의 상태 정보를 요청한다. 클라이언트의 GET 요청 메시지는 바디 없이 헤더 로만 구성된다.
웹은 구조상 GET 메서드의 특성에 많이 의존한다. 클라이언트에서 GET 요청을 반복해도 문제가 없어야 하며, 캐시는 리소스를 제공하는 원래 서버와 통신하지 않 고도 캐시된 내용을 제공할 수 있어야 한다.
다음 예제는 클라이언트 개발자가 명령 셸에서 curl을 사용하여 ‘greeting’이라는 리소스의 현재 상태 표현을 GET하는 것이다.


url 명령을 나타낸다. GET은 curl의 기본 메서드이기 때문에 명시적으로 입 력하지 않아도 된다. -v 옵션은 curl 명령의 결과를 자세히 표시하기 위해 사용 한다.
2 요청 메시지의 Request-Line은 greeting 리소스에 대해 GET 메서드를 사용 한 것을 나타낸다.
3 요청 메시지의 헤더 리스트의 시작 부분이다. HTTP 요청과 응답 헤더에 대해 서는 4장에서 다룬다.
4 응답 메시지의 시작 부분이다. Status-Line은 ‘응답 상태 코드’ 부분에서 설 명한다. ‘200 OK’ 상태 코드는 요청이 성공했음을 알리는 코드다.
응답 메시지 헤더 리스트의 시작 부분이다.
6 응답 메시지 바디의 시작 부분이다. 이 예제에서 바디는 greeting 메시지의
HTML 형태로 작성된 표현이다.


규칙: 응답 헤더를 가져올 때는 반드시 HEAD 메서드를 사용해야 한다
클라이언트는 HEAD 메서드를 사용하여 헤더 정보만 가져온다. 즉, HEAD 메서드 는 GET 메서드와 동일한 응답을 주지만, 바디가 없다. 클라이언트는 HEAD 메서 드를 사용하여 리소스 존재 여부를 확인하거나 메타데이터만 읽을 수 있다.
다음 예제는 HEAD 메서드를 이용하여 헤더 정보를 요청하는 curl 명령이다.

규칙: PUT 메서드는 리소스를 삽입하거나 저장된 리소스를 갱신하는 데 사용해 야 한다
PUT 메서드는 클라이언트가 기술한 URI로 스토어에 새로운 리소스를 추가하는 데 사용한다. 이미 스토어에 저장된 리소스를 갱신하거나 다른 것으로 대체하는 데 도 PUT 메서드를 사용한다.
다음 예제는 클라이언트 애플리케이션에서 애플리케이션의 데이터를 서버에 객체 로 저장할 수 있는 스토어 리소스를 제공하는 REST API를 나타낸다.
PUT /accounts/4ef2d5d0-cb7e-11e0-9572-0800200c9a66/buckets/objects/4321
PUT 요청 메시지에는 클라이언트에서 저장하려는 리소스를 표현하는 부분이 포 함되어야 한다. 그러나 요청 메시지의 바디에 포함된 리소스에 대한 표현이 GET 요청을 통해서 받는 리소스에 대한 표현과 같을 수도 있고 같지 않을 수도 있다. 예 를 들어, REST API의 스토어 리소스에서 요청 메시지에 리소스 상태 표현 중 변경 되는 부분만 표현하는 것을 허용할 수도 있다.
4장 “규칙: 스토어는 조건부 PUT 요청을 지원해야 한다”에서, REST API가 HTTP 헤더를 사용하여 PUT 메서드를 리소스에 삽입하거나 갱신할 때 오버로딩하는 방 법을 설명할 것이다.
규칙: PUT 메서드는 변경 가능한 리소스를 갱신하는 데 사용해야 한다
클라이언트는 PUT 요청 메서드를 사용해서 리소스를 변경한다. PUT 요청 메시지 에는 원하는 형태로 변경된 메시지 바디를 포함할 수 있다.
규칙: POST 메서드는 컬렉션에 새로운 리소스를 만드는 데 사용해야 한다
클라이언트는 POST 메서드를 사용해서 컬렉션 안에 새로운 리소스를 만든다. POST 요청 바디는 새로운 리소스를 위해 제안된 상태 표현을 포함하는데, 이것은

서버 소유의 컬렉션에 추가된다.
다음 예제는 클라이언트가 POST를 사용해서 컬렉션에 새로운 추가 사항을 요청 하는 것을 보여준다.
POST /leagues/seattle/teams/trebuchet/players
#요청 메시지는 만들어질 플레이어의 초기 상태를 제안하는 상태를 포함할 수 있다.
이것은 REST API 설계할 때 POST 메서드를 사용하는 두 가지 방법 중 첫 번째에 해당한다. 이렇게 POST 메서드를 사용하는 것은 게시판에 새로운 메시지를 등록 하는 것과 비슷하다.
규칙: POST 메서드는 컨트롤러를 실행하는 데 사용해야 한다
클라이언트는 POST 메서드를 사용해서 기능 지향적인 컨트롤러 리소스를 동작시 킨다. POST 요청 메시지는 컨트롤러 리소스 기능의 입력 값을 헤더나 바디에 포함 할 수 있다.
HTTP 표준에서는 POST 메서드에 의미상의 제한을 두지 않으며, 반복이나 부작 용과 상관없이 어떤 액션도 수행할 수 있다. 이런 특징 때문에, POST 메서드를 제 한 없는 컨트롤러 리소스로 사용할 수 있다.
REST API 디자인은 컨트롤러 리소스로 모든 동작을 실행하기 위해 POST 메서드 를 사용하는데, 각 기능 및 동작은 직관적으로 HTTP 메서드들과 매핑되지 않는 다. 다시 말해, POST 메서드는 리소스를 가지고 오거나, 저장하거나, 지우는 데 사 용하지는 않는다(HTTP는 이런 기능에 대해서는 각각 다른 메서드를 사용한다).
POST 요청 메서드는 안전하지도 않고 사용할 때마다 리소스의 상태 값이 계속 바 뀔 수 있다. 즉, POST의 결과를 예측할 수도, 부작용 없이 반복적으로 사용하는 것 을 보장할 수도 없다는 의미다. 예를 들어, POST 메서드를 사용하여 웹 폼을 두 번
3장 HTTP를 이용한 인터랙션 설계 33 This eBook is licensed to 김민영(cyzest@nate.com). Personal use only
 제출하면, 사용자의 신용카드가 두 번 결제되는 상황이 발생할 수도 있다. 컨트롤 러 리소스는 유연성을 높이기 위해 투명도와 강건성을 조정해야 한다.
다음 예제는 POST 요청 메서드를 사용하여 컨트롤러가 수행되는 것을 보여준다.
POST /alerts/245743/resend
이것이 REST API 디자인에서 POST 메서드를 사용하는 두 번째 방법이다. 이 예 는 널리 알려진 콘셉트인 런타임 시스템의 PostMessage 메커니즘과 유사한데, 어 떤 경계를 넘어야 기능들이 실행된다.
규칙: DELETE 메서드는 그 부모에서 리소스를 삭제하는 데 사용해야 한다
클라이언트는 DELETE 메서드 요청을 사용하여 컬렉션이나 스토어인 부모에서 리 소스를 완전히 제거한다. 주어진 리소스에 DELETE 요청이 수행되면, 클라이언트는 그 리소스를 볼 수 없게 된다. 따라서 GET 메서드나 HEAD 메서드로 리소스의 현재 상태를 가져오려는 어떤 API 시도도 404(“Not Found”) 상태로 끝나게 된다.
다음 예제는 클라이언트가 스토어에서 도큐먼트를 제거하는 방법이다.
DELETE /accounts/4ef2d5d0-cb7e-11e0-9572-0800200c9a66/buckets/objects/4321
DELETE 메서드는 HTTP에서 매우 명확한 의미로 사용되며, REST API 디자인 에 오버로드되거나 확장될 수 없다. 어떤 경우에도, 클라이언트에서 사용할 수 있 는 리소스나 URI로 삭제하지 않는 기능에 DELETE 메서드를 사용하여 원래 의미 를 왜곡해서는 안 된다. 예를 들어, 어떤 API에서 리소스를 완전히 지우지 않고 임 시 삭제 기능을 제공하거나 상태만을 바꾸는 기능을 제공하려면, 특별한 컨트롤러 리소스를 채택하고 클라이언트가 DELETE 메서드 대신 POST 메서드를 사용해야 한다.
3장 HTTP를 이용한 인터랙션 설계 34
규칙: OPTIONS 메서드는 리소스의 사용 가능한 인터랙션을 기술한 메타데 이터를 가져오는 데 사용해야 한다
클라이언트는 OPTIONS 메서드를 사용하여 Allow 헤더에 포함된 리소스 메타 데이터를 가져온다. 예를 들어, 다음처럼 사용 가능한 GET 메서드, PUT 메서드, DELETE 메서드를 가져온다.
Allow: GET, PUT, DELETE
REST API는 OPTIONS 메서드 요청에 대한 응답으로 각 인터랙션 항목의 세부 사 항을 바디에 포함할 수 있다. 응답 바디에는 링크 관계 폼 리스트를 포함할 수도 있 는데, 이에 대해서는 5장의 “규칙: 링크 관계를 표현할 때에는 일관된 형태를 사용 해야 한다”에서 알아볼 것이다.

## 응답 상태 코드

REST API는 HTTP 응답 메시지의 Status-Line 부분을 사용하여 클라이언트가 요 청한 결과를 알려준다. RFC 2616에서 Status-Line 문법을 다음처럼 정의하였다.
Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
HTTP는 40개의 표준 상태 코드를 정의하여 클라이언트가 요청한 결과를 전달하 는 데 사용한다. 상태 코드는 표 3-1에서처럼 다섯 가지 범주로 분류한다.
표 3-1 응답 상태 코드 범주
1xx: 정보
2xx: 성공
3xx: 재전송
4xx: 클라이언트 오류 5xx: 서버 오류
전송 프로토콜 수준의 정보 교환
클라이언트 요청이 성공적으로 수행됨
클라이언트는 요청을 완료하기 위해 추가적인 행동을 취해야 함 클라이언트의 잘못된 요청
서버쪽 오류로 인한 상태 코드
범주
설명
          3장 HTTP를 이용한 인터랙션 설계
This eBook is licensed to 김민영(cyzest@nate.com). Personal use only
35
 이 부분에서는 상태 코드의 일부를 REST API 디자인에 적용할 때 언제, 어떻게 사 용하는지를 간단히 설명할 것이다.
규칙: 200(“OK”)는 일반적인 요청 성공을 나타내는 데 사용해야 한다
200은 클라이언트가 요청한 어떤 액션이었든지 REST API가 성공적으로 수행했 음을 나타내는 코드로, 클라이언트는 이 코드를 받길 원한다. 또한 더 이상의 할당 된 '2xx'계열의 응답코드가 없다는 뜻이기도 하다. 204 상태 코드와는 달리, 200 응답은 응답 바디가 포함된다.
규칙: 200(“OK”)는 응답 바디에 에러를 전송하는 데 사용해서는 안 된다
항상 이 부분에 기술한 규칙을 사용하여 적절한 HTTP 응답 상태 코드를 사용한 다. 특히, REST API는 부실한 HTTP 클라이언트에 부합하려는 그 어떤 타협도 해 서는 안 된다.
규칙: 201(“Created”)는 성공적으로 리소스를 생성했을 때 사용해야 한다
REST API는 클라이언트의 요청으로 새로운 리소스를 이용하여 컬렉션에 생성했 거나 스토어에 추가했을 때 201 상태 코드로 응답한다. 컨트롤러의 행동으로 새로 운 리소스가 생겨났을 경우에도 201 상태 코드로 응답한다.
규칙: 202(“Accepted”)는 비동기 처리가 성공적으로 시작되었음을 알릴 때 사용해야 한다
202 응답은 클라이언트의 요청이 비동기적으로 처리될 것임을 나타낸다. 이 응답 상태 코드는 유효한 요청이었지만, 최종적으로 처리되기까지는 문제가 생길 수도 있다는 것을 클라이언트에게 알려준다. 보통 202 응답은 처리 시간이 오래 걸리는 액션에 사용된다. 컨트롤러 리소스는 202 응답을 보낼 수 있지만 다른 리소스 타 입은 보낼 수 없다.
3장 HTTP를 이용한 인터랙션 설계 36
 규칙: 204(“No Content”)는 응답 바디에 의도적으로 아무것도 포함하지 않 을 때 사용한다
204 상태 코드는 보통 PUT, POST, DELETE 요청에 대한 응답으로 이용하는데, REST API가 응답 메시지의 바디에 어떠한 상태 메시지나 표현을 포함해서 보내지 않을 때 사용한다. API는 GET 요청에 204로 응답할 수 있는데, 요청된 리소스는 존재하나 바디에 포함시킬 어떠한 상태 표현도 가지고 있지 않다는 것을 나타낸다.
규칙: 301(“Moved Permanently”)는 리소스를 이동시켰을 때 사용한다
301 상태 코드는 REST API 리소스 모델이 상당 부분 재설계되었거나 계속 사용할 새로운 URI를 클라이언트가 요청한 리소스에 할당하였다는 것을 나타낸다. REST API는 응답의 Location 헤더에 새로운 URI를 기술해야 한다.
규칙: 302(“Found”)는 사용하지 않는다
많은 프로그래머가 302 응답 코드의 원래 의미를 잘못 이해하고 HTTP 버전02 1.0 이래로 부정확하게 구현하고 있다. 이러한 혼란의 중심에는 클라이언트에서 최초 의 요청 메서드와 무관하게 응답 메시지의 Location 헤더에 있는 URI로 연이어 GET 요청을 자동으로 보내는 것이 적절한지에 대한 논란이 존재한다. 302의 공식 적인 의도는 이러한 자동 재전송은 클라이언트가 GET이나 HEAD를 사용하여 최 초 요청을 한 경우에만 적용하는 것이다.
HTTP 1.1에서는 이 문제를 해결하기 위해 302대신 303(“See Other”)과 307(“Temporary Redirect”)을 도입했다.
규칙: 303(“See Other”)은 다른 URI를 참조하라고 알려줄 때 사용한다
303 응답은 처리가 끝난 컨트롤러 리소스가 잠재적으로 원하지 않는 응답 바디를
02 HTTP/1.0 의 302 상태 코드의 문구는 ‘Moved Temporarily’이다.
3장 HTTP를 이용한 인터랙션 설계 37 This eBook is licensed to 김민영(cyzest@nate.com). Personal use only
 
 보내는 대신, 응답 리소스의 URI를 보냈음을 나타낸다. 이것은 임시 상태 메시지 의 URI일 수도 있고, 이미 존재하는 영구적인 리소스의 URI일 수도 있다.
303 상태 코드는 일반적으로 REST API가 클라이언트에 상태 다운로드를 강요 하지 않으면서 참조 리소스를 보내는 것을 허용한다. 대신 클라이언트는 응답 Location 헤더에 있는 값으로 GET 요청을 보낼 수 있다.
규칙: 304(“Not Modified”)는 대역폭을 절약할 때 사용한다
이 상태 코드는 응답 바디에 아무것도 없어야 한다는 측면에서 204(“No Content”) 와 유사하다. 주요 차이점은 204는 바디에 보낼 내용이 없을 때 사용하는 반면, 304는 리소스에 대한 상태 정보가 있긴 하지만 클라이언트에 이미 해당 상태의 최 신 버전이 있다는 걸 의미할 때 사용한다.
이 상태 코드는 조건부 HTTP 요청과 함께 사용하는데, 4장에서 자세히 살펴볼 것 이다.
규칙: 307(“Temporary Redirect”)는 클라이언트가 다른 URI로 요청을 다 시 보내게 할 때 사용해야 한다
HTTP/1.1은 최초의 302(“Found”) 상태 코드 의미를 반복하기 위해 307 응답 코 드를 도입하였다. 307 응답은 REST API가 클라이언트의 요청을 처리하지 않을 것임을 나타낸다. 클라이언트는 응답 메시지의 Location 헤더에 기술된 URI로 요 청을 다시 보내야 한다.
REST API는 요청된 클라이언트의 리소스에 임시 URI를 할당하여 상태 코드를 사 용할 수 있다. 예를 들면, 307 응답은 클라이언트 요청을 다른 호스트로 바꾸는 데 사용한다.
3장 HTTP를 이용한 인터랙션 설계 38
 규칙: 400(“Bad Request”)는 일반적인 요청 실패에 사용해야 한다
400은 다른 적절한 ‘4xx’ 오류 값이 없을 때 사용하는 일반적인 클라이언트의 에 러 상태다.
 ‘4xx’ 범주의 오류는 클라이언트의 오류를 기술하는 도큐먼트를 응답 바디에 포함할 수 있다 (요청 메서드가 HEAD일 경우는 제외). 오류 응답 바디 디자인은 5장의 ‘오류 표현’을 참고한다.
 규칙: 401(“Unauthorized”)는 클라이언트 인증에 문제가 있을 때 사용해야 한다
401 오류 응답은 클라이언트가 적절한 인증 없이 보호된 리소스를 사용하려고 할 때 발생한다. 인증을 잘못하거나 아예 인증하지 못할 경우 발생한다.
규칙: 403(“Forbidden”)은 인증 상태에 상관없이 액세스를 금지할 때 사용 해야 한다
403 오류 응답은 클라이언트의 요청은 정상이지만, REST API가 요청에 응 하지 않는 경우를 나타낸다. 즉, 403 응답은 클라이언트의 인증에 문제가 있 어서 발생하는 것이 아니다. 만약 클라이언트 인증 자체에 문제가 있다면 401(“Unauthorized”)를 사용한다.
REST API에서 애플리케이션 수준의 접근 권한을 적용하고자 할 때 403을 사용한 다. 예를 들어, 클라이언트는 REST API 리소스의 전체가 아니라 일부에 대한 접근 만 허가된 경우가 있다. 클라이언트가 허용된 범위 외의 리소스에 접근하려고 할 때 REST API는 403으로 응답해야 한다.
3장 HTTP를 이용한 인터랙션 설계 39 This eBook is licensed to 김민영(cyzest@nate.com). Personal use only
 규칙: 404(“Not Found”)는 요청 URI에 해당하는 리소스가 없을 때 사용해 야 한다
404 오류 상태 코드는 말그대로 클라이언트가 요청한 URI에 해당하는 리소스가 존재하지 않을 때 사용한다.
규칙: 405(“Method Not Allowed”)는 HTTP 메서드가 지원되지 않을 때 사용해야 한다
클라이언트가 허용되지 않은 HTTP 메서드를 사용하려 할 때, API는 405 오류 응 답을 한다. 읽기 전용 리소스는 GET 메서드와 HEAD 메서드만 지원하며, 컨트롤 러 리소스는 PUT 메서드와 DELETE 메서드를 제외한 GET 메서드와 POST 메서 드만 허용할 것이다.
405 응답에는 Allow 헤더가 포함되어야 하며, 그 값으로 리소스가 지원하는 HTTP 메서드를 다음 예와 같이 나타내야 한다.
Allow: GET, POST
규칙: 406(”Not Acceptable”)은 요청된 리소스 미디어 타입을 제공하지 못 할 때 사용해야 한다
406 오류 응답은 클라이언트의 Accept 요청 헤더에 있는 미디어 타입 중 해당하 는 것을 만들지 못할 때 발생한다. 예를 들어, API가 json(application/json) 데 이터 포맷만 지원한다면, xml(application/xml) 포맷 데이터를 요청한 클라이언 트는 406 응답을 받는다.
규칙: 409(“Conflict”)는 리소스 상태에 위반되는 행위를 했을 때 사용해야 한다
409 오류 응답은 클라이언트 요청에 의해 REST API 리소스가 불가능 또는 모순
3장 HTTP를 이용한 인터랙션 설계 40
상태가 될 수 있는 경우에 사용한다. 예를 들어, 클라이언트가 비어 있지 않은 스토 어 리소스를 삭제하라고 요청하면, REST API에서 이 응답 오류를 보낸다.
규칙: 412(“Precondition Failed”)는 조건부 연산을 지원할 때 사용한다
412 오류 응답은 특정한 조건이 만족될 때만 요청이 수행되도록 REST API로 알려 준다. 클라이언트가 요청 헤더에 하나 이상의 전제 조건을 지정할 경우 발생하며, 이러한 조건이 만족되지 않으면 412 응답은 요청을 수행하는 대신에 이 상태 코드 를 보낸다.
“규칙: 스토어는 조건부 PUT 요청을 지원해야 한다”에서 설명된 412 상태 코드 사 용의 예를 참고한다.
규칙: 415(“Unsupported Media Type”)은 요청의 페이로드에 있는 미디 어 타입이 처리되지 못했을 때 사용해야 한다
415 오류 응답은 요청 헤더의 Content-Type에 기술한 클라이언트가 제공한 미 디어 타입을 처리하지 못할 때 발생한다. 예를 들어, API가 json(application/ json)으로 포맷된 데이터만 처리할 수 있을 때, 클라이언트가 xml(application/ xml)로 포맷된 데이터로 요청하면 415 응답을 받는다.
규칙: 500(“Internal Server Error”)는 API가 잘못 작동할 때 사용해야 한다
500은 일반적인 REST API 오류 응답이다. 웹 프레임워크는 대부분 예외 사항을 발생시키는 요청 핸들러 코드가 실행될 경우 자동적으로 이 응답 코드를 발생시킨 다. 500 오류는 클라이언트의 잘못으로 발생한 것이 아니기 때문에, 클라이언트가 이 응답을 발생시킨 것과 같은 요청을 다시 시도하면 다른 응답을 받을 수도 있다.


